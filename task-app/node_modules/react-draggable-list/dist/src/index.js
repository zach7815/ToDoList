"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var React = _interopRequireWildcard(require("react"));

var PropTypes = _interopRequireWildcard(require("prop-types"));

var _reactMotion = require("react-motion");

var _immutabilityHelper = _interopRequireDefault(require("immutability-helper"));

var _reactMultiRef = _interopRequireDefault(require("react-multi-ref"));

var _OnUpdate = _interopRequireDefault(require("./OnUpdate"));

var _MoveContainer = _interopRequireDefault(require("./MoveContainer"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var DEFAULT_HEIGHT = {
  natural: 200,
  drag: 30
};

function getScrollSpeed(distance, speed, size) {
  // If distance is zero, then the result is the max speed. Otherwise,
  // the result tapers toward zero as it gets closer to the opposite
  // edge of the region.
  return Math.round(speed - speed / size * distance);
}

var DraggableList = /*#__PURE__*/function (_React$Component) {
  (0, _inherits2["default"])(DraggableList, _React$Component);

  var _super = _createSuper(DraggableList);

  function DraggableList() {
    var _this;

    (0, _classCallCheck2["default"])(this, DraggableList);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_itemRefs", new _reactMultiRef["default"]());
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_listRef", /*#__PURE__*/React.createRef());
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "state", {
      useAbsolutePositioning: false,
      dragging: false,
      lastDrag: null,
      heights: null
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_handleTouchMove", function (e) {
      e.preventDefault();

      _this._handleMouseMove(e.touches[0]);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_handleMouseMove", function (_ref) {
      var pageY = _ref.pageY,
          clientY = _ref.clientY;
      var list = _this.props.list;
      var autoScrollMaxSpeed = _this.props.autoScrollMaxSpeed;
      var autoScrollRegionSize = _this.props.autoScrollRegionSize;
      var _this$state = _this.state,
          dragging = _this$state.dragging,
          lastDrag = _this$state.lastDrag;
      if (!dragging || !lastDrag) return;

      var containerEl = _this._getContainer();

      var dragVisualIndex = _this._getDragVisualIndex();

      var keyFn = _this._getKeyFn();

      clearInterval(_this._autoScrollerTimer); // If the user has the mouse near the top or bottom of the container and
      // not at the end of the list, then autoscroll.

      if (dragVisualIndex !== 0 && dragVisualIndex !== list.length - 1) {
        var scrollSpeed = 0;
        var containerRect = containerEl && containerEl !== document.body && containerEl.getBoundingClientRect ? containerEl.getBoundingClientRect() : {
          top: 0,
          bottom: Infinity
        }; // Get the lowest of the screen top and the container top.

        var top = Math.max(0, containerRect.top);
        var distanceFromTop = clientY - top;

        if (distanceFromTop > 0 && distanceFromTop < autoScrollRegionSize) {
          scrollSpeed = -1 * getScrollSpeed(distanceFromTop, autoScrollMaxSpeed, autoScrollRegionSize);
        } else {
          // Get the lowest of the screen bottom and the container bottom.
          var bottom = Math.min(window.innerHeight, containerRect.bottom);
          var distanceFromBottom = bottom - clientY;

          if (distanceFromBottom > 0 && distanceFromBottom < autoScrollRegionSize) {
            scrollSpeed = getScrollSpeed(distanceFromBottom, autoScrollMaxSpeed, autoScrollRegionSize);
          }
        }

        if (scrollSpeed !== 0) {
          _this._scrollContainer(scrollSpeed);

          _this._autoScrollerTimer = setTimeout(function () {
            _this._handleMouseMove({
              pageY: pageY + (containerEl === document.body ? scrollSpeed : 0),
              clientY: clientY
            });
          }, 16);
        }
      }

      var containerScroll = !containerEl || containerEl === document.body ? 0 : containerEl.scrollTop;
      var mouseY = pageY - lastDrag.mouseOffset + containerScroll;

      if (_this.props.constrainDrag) {
        var visualList = _this._getVisualListDuringDrag();

        mouseY = Math.max(mouseY, _this._getDistanceFromTopDuringDrag(lastDrag, keyFn(visualList[0]), visualList));
        mouseY = Math.min(mouseY, _this._getDistanceFromTopDuringDrag(lastDrag, keyFn(visualList[visualList.length - 1]), visualList));
      }

      _this.setState({
        lastDrag: _objectSpread(_objectSpread({}, lastDrag), {}, {
          mouseY: mouseY
        })
      });
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_handleMouseUp", function () {
      clearInterval(_this._autoScrollerTimer);
      window.removeEventListener('mouseup', _this._handleMouseUp);
      window.removeEventListener('touchend', _this._handleMouseUp);
      window.removeEventListener('touchmove', _this._handleTouchMove);
      window.removeEventListener('mousemove', _this._handleMouseMove);
      if (document.documentElement) document.documentElement.style.cursor = '';
      _this._lastScrollDelta = 0;
      var _this$props = _this.props,
          list = _this$props.list,
          onMoveEnd = _this$props.onMoveEnd,
          onDragEnd = _this$props.onDragEnd;
      var _this$state2 = _this.state,
          dragging = _this$state2.dragging,
          lastDrag = _this$state2.lastDrag;

      if (dragging && lastDrag && onMoveEnd) {
        var dragIndex = _this._getDragListIndex();

        var _newIndex = _this._getDragVisualIndex();

        if (dragIndex !== _newIndex) {
          var _newList = _this._getVisualListDuringDrag();

          onMoveEnd(_newList, list[dragIndex], dragIndex, _newIndex);
        }

        if (onDragEnd) {
          onDragEnd();
        }

        _this.setState({
          dragging: false
        });
      }
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_lastScrollDelta", 0);
    return _this;
  }

  (0, _createClass2["default"])(DraggableList, [{
    key: "getItemInstance",
    value: function getItemInstance(key) {
      var ref = this._itemRefs.map.get(key);

      if (!ref) throw new Error('key not found');
      return ref.getTemplate();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._handleMouseUp();
    }
  }, {
    key: "_handleTouchStart",
    value: function _handleTouchStart(itemKey, pressY, event) {
      event.stopPropagation();

      this._handleStartDrag(itemKey, pressY, event.touches[0].pageY);
    }
  }, {
    key: "_handleMouseDown",
    value: function _handleMouseDown(itemKey, pressY, event) {
      event.preventDefault();

      this._handleStartDrag(itemKey, pressY, event.pageY);
    }
  }, {
    key: "_handleStartDrag",
    value: function _handleStartDrag(itemKey, pressY, pageY) {
      var _this2 = this;

      if (document.documentElement) document.documentElement.style.cursor = 'move';
      window.addEventListener('mouseup', this._handleMouseUp);
      window.addEventListener('touchend', this._handleMouseUp);
      window.addEventListener('touchmove', this._handleTouchMove);
      window.addEventListener('mousemove', this._handleMouseMove);

      if (this.props.onDragStart) {
        this.props.onDragStart();
      } // If an element has focus while we drag around the parent, some browsers
      // try to scroll the parent element to keep the focused element in view.
      // Stop that.


      {
        var listEl = this._listRef.current;
        if (!listEl) throw new Error('Should not happen');

        if (listEl.contains && document.activeElement && listEl.contains(document.activeElement) && document.activeElement instanceof HTMLElement) {
          document.activeElement.blur();
        }
      }

      var keyFn = this._getKeyFn();

      var newHeights = null;

      if (this.state.heights == null) {
        var _newHeights = Object.create(null);

        this.props.list.forEach(function (item) {
          var key = keyFn(item);

          var containerRef = _this2._itemRefs.map.get(key);

          var refEl = containerRef ? containerRef.getDOMNode().firstElementChild : null;
          var ref = containerRef ? containerRef.getTemplate() : null;
          var natural = refEl instanceof HTMLElement ? refEl.offsetHeight : DEFAULT_HEIGHT.natural;
          var drag = ref && typeof ref.getDragHeight === 'function' && ref.getDragHeight() || natural;
          _newHeights[key] = {
            natural: natural,
            drag: drag
          };
        });
        newHeights = _newHeights;
      } // Need to re-render once before we start dragging so that the `y` values
      // are set using the correct state.heights and then can animate from there.


      var afterHeights = function afterHeights() {
        var itemIndex = _this2.props.list.map(keyFn).indexOf(itemKey); // pressY will be non-null if the list is currently animating (because the
        // clicked item has its `y` prop set). pressY will be null if the list is
        // not currently animating (because the clicked item will be at its
        // natural position, which is calculatable using _getDistance).


        var startY = pressY == null ? _this2._getDistance(0, itemIndex, false) : pressY;

        var containerEl = _this2._getContainer();

        var containerScroll = !containerEl || containerEl === document.body ? 0 : containerEl.scrollTop;

        _this2.setState({
          useAbsolutePositioning: true,
          dragging: true,
          lastDrag: {
            itemKey: itemKey,
            startY: startY,
            mouseY: startY,
            mouseOffset: pageY - startY + containerScroll
          }
        });
      };

      if (newHeights) {
        this.setState({
          heights: newHeights
        }, afterHeights);
      } else {
        afterHeights();
      }
    }
  }, {
    key: "_scrollContainer",
    value: function _scrollContainer(delta) {
      var containerEl = this._getContainer();

      if (!containerEl) return;

      if (window.scrollBy && containerEl === document.body) {
        window.scrollBy(0, delta);
      } else {
        containerEl.scrollTop += delta;
      }
    }
  }, {
    key: "_adjustScrollAtEnd",
    value: function _adjustScrollAtEnd(delta) {
      var frameDelta = Math.round(delta - this._lastScrollDelta);

      this._scrollContainer(frameDelta);

      this._lastScrollDelta += frameDelta;
    }
  }, {
    key: "_getDragListIndex",
    value: function _getDragListIndex() {
      var list = this.props.list;
      var lastDrag = this.state.lastDrag;

      if (!lastDrag) {
        throw new Error('No drag happened');
      }

      var keyFn = this._getKeyFn();

      return DraggableList._getIndexOfItemWithKey(keyFn, list, lastDrag.itemKey);
    }
  }, {
    key: "_getDragVisualIndex",
    value: function _getDragVisualIndex() {
      var list = this.props.list;
      var padding = this.props.padding;
      var _this$state3 = this.state,
          dragging = _this$state3.dragging,
          lastDrag = _this$state3.lastDrag;
      if (!dragging || !lastDrag) throw new Error('Should not happen');

      var dragListIndex = this._getDragListIndex();

      var mouseY = lastDrag.mouseY,
          startY = lastDrag.startY;
      var movementFromNatural = mouseY - startY; // 1 down, -1 up, 0 neither

      var direction = movementFromNatural > 0 ? 1 : movementFromNatural < 0 ? -1 : 0;
      var newIndex = dragListIndex;

      if (direction !== 0) {
        var keyFn = this._getKeyFn();

        var reach = Math.abs(movementFromNatural);

        for (var i = dragListIndex + direction; i < list.length && i >= 0; i += direction) {
          var iDragHeight = this._getItemHeight(keyFn(list[i])).drag;

          if (reach < iDragHeight / 2 + padding) break;
          reach -= iDragHeight + padding;
          newIndex = i;
        }
      }

      return newIndex;
    }
  }, {
    key: "_getVisualListDuringDrag",
    value: function _getVisualListDuringDrag() {
      var list = this.props.list;
      var _this$state4 = this.state,
          dragging = _this$state4.dragging,
          lastDrag = _this$state4.lastDrag;
      if (!dragging || !lastDrag) throw new Error('Should not happen: _getVisualListDuringDrag called outside of drag');

      var dragListIndex = this._getDragListIndex();

      var dragVisualIndex = this._getDragVisualIndex();

      return (0, _immutabilityHelper["default"])(list, {
        $splice: [[dragListIndex, 1], [dragVisualIndex, 0, list[dragListIndex]]]
      });
    }
  }, {
    key: "_getItemHeight",
    value: function _getItemHeight(key) {
      return this.state.heights != null && key in this.state.heights ? this.state.heights[key] : DEFAULT_HEIGHT;
    } // Get the distance between the tops of two items in the list.
    // Does not consider how the dragged item may be rendered in a different position
    // unless you pass in the re-ordered list as a parameter.

  }, {
    key: "_getDistance",
    value: function _getDistance(start, end, dragging) {
      var list = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.props.list;

      if (end < start) {
        return -this._getDistance(end, start, dragging, list);
      }

      var padding = this.props.padding;

      var keyFn = this._getKeyFn();

      var distance = 0;

      for (var i = start; i < end; i++) {
        var height = this._getItemHeight(keyFn(list[i]));

        distance += (dragging ? height.drag : height.natural) + padding;
      }

      return distance;
    }
  }, {
    key: "_getDistanceFromTopDuringDrag",
    value: function _getDistanceFromTopDuringDrag(lastDrag, itemKey, visualList) {
      var keyFn = this._getKeyFn();

      var index = DraggableList._getIndexOfItemWithKey(keyFn, visualList, itemKey);

      var dragListIndex = this._getDragListIndex();

      var dragVisualIndex = DraggableList._getIndexOfItemWithKey(keyFn, visualList, lastDrag.itemKey);

      var offset = 0;

      if (dragVisualIndex < dragListIndex) {
        var dragItemHeight = this._getItemHeight(lastDrag.itemKey);

        var newCenterHeight = this._getItemHeight(keyFn(visualList[dragListIndex]));

        offset = dragItemHeight.drag - newCenterHeight.drag;
      }

      return lastDrag.startY + offset + this._getDistance(dragListIndex, index, true, visualList);
    }
  }, {
    key: "_getContainer",
    value: function _getContainer() {
      var container = this.props.container;
      return container ? container() : null;
    }
  }, {
    key: "_getKeyFn",
    value: function _getKeyFn() {
      return DraggableList._getKeyFn(this.props.itemKey);
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var padding = this.props.padding;
      var _this$props2 = this.props,
          list = _this$props2.list,
          springConfig = _this$props2.springConfig,
          container = _this$props2.container,
          template = _this$props2.template,
          unsetZIndex = _this$props2.unsetZIndex,
          commonProps = _this$props2.commonProps;
      var _this$state5 = this.state,
          dragging = _this$state5.dragging,
          lastDrag = _this$state5.lastDrag,
          useAbsolutePositioning = _this$state5.useAbsolutePositioning;

      var keyFn = this._getKeyFn();

      var anySelected = (0, _reactMotion.spring)(dragging ? 1 : 0, springConfig);
      var visualList = dragging ? this._getVisualListDuringDrag() : list;
      var children = list.map(function (item, i) {
        var key = keyFn(item);
        var selectedStyle = dragging && lastDrag && lastDrag.itemKey === key ? {
          itemSelected: (0, _reactMotion.spring)(1, springConfig),
          y: lastDrag.mouseY
        } : {
          itemSelected: (0, _reactMotion.spring)(0, springConfig),
          y: (useAbsolutePositioning ? _reactMotion.spring : function (x) {
            return x;
          })(dragging && lastDrag ? _this3._getDistanceFromTopDuringDrag(lastDrag, key, visualList) : _this3._getDistance(0, i, false), springConfig)
        };

        var style = _objectSpread({
          anySelected: anySelected
        }, selectedStyle);

        var makeDragHandleProps = function makeDragHandleProps(getY) {
          return {
            onMouseDown: function onMouseDown(e) {
              return _this3._handleMouseDown(key, getY(), e);
            },
            onTouchStart: function onTouchStart(e) {
              return _this3._handleTouchStart(key, getY(), e);
            }
          };
        };

        var height = _this3._getItemHeight(key);

        return /*#__PURE__*/React.createElement(_reactMotion.Motion, {
          style: style,
          key: key,
          children: function children(_ref2) {
            var itemSelected = _ref2.itemSelected,
                anySelected = _ref2.anySelected,
                y = _ref2.y;
            return /*#__PURE__*/React.createElement(_MoveContainer["default"], {
              ref: _this3._itemRefs.ref(key),
              y: useAbsolutePositioning ? y : undefined,
              template: template,
              padding: padding,
              item: item,
              itemSelected: itemSelected,
              anySelected: anySelected,
              height: height,
              zIndex: unsetZIndex && !useAbsolutePositioning ? 'auto' : lastDrag && lastDrag.itemKey === key ? list.length : i,
              makeDragHandleProps: makeDragHandleProps,
              commonProps: commonProps
            });
          }
        });
      });
      var adjustScroll = 0;

      if (!dragging && lastDrag && useAbsolutePositioning) {
        var dragListIndex = this._getDragListIndex();

        adjustScroll = (0, _reactMotion.spring)(this._getDistance(0, dragListIndex, false) - lastDrag.mouseY, springConfig);
      }

      var heightReserverHeight = 0;
      var heightReserverMarginBottom = 0;

      if (list.length) {
        heightReserverMarginBottom = padding;

        if (useAbsolutePositioning) {
          heightReserverHeight = this._getDistance(0, list.length, false) - padding;
        }
      }

      return /*#__PURE__*/React.createElement("div", {
        style: {
          position: 'relative'
        },
        ref: this._listRef
      }, /*#__PURE__*/React.createElement(_reactMotion.Motion, {
        style: {
          adjustScroll: adjustScroll,
          anySelected: anySelected
        },
        onRest: function onRest() {
          if (!dragging) {
            _this3.setState({
              heights: null,
              useAbsolutePositioning: false
            });
          }
        },
        children: function children(_ref3) {
          var adjustScroll = _ref3.adjustScroll;
          return /*#__PURE__*/React.createElement("div", {
            style: {
              display: useAbsolutePositioning ? 'block' : 'none',
              height: "".concat(heightReserverHeight, "px"),
              marginBottom: "".concat(heightReserverMarginBottom, "px")
            }
          }, container && /*#__PURE__*/React.createElement(_OnUpdate["default"], {
            cb: function cb() {
              if (!dragging && lastDrag && useAbsolutePositioning) {
                _this3._adjustScrollAtEnd(adjustScroll);
              }
            }
          }));
        }
      }), children);
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(newProps, state) {
      var list = newProps.list;
      var lastDrag = state.lastDrag;

      if (lastDrag) {
        var keyFn = DraggableList._getKeyFn(newProps.itemKey);

        try {
          DraggableList._getIndexOfItemWithKey(keyFn, list, lastDrag.itemKey);
        } catch (err) {
          // If the dragged item was removed from the list, this block will get hit.
          // Cancel the drag.
          return {
            dragging: false,
            lastDrag: null
          };
        }
      }

      return null;
    }
  }, {
    key: "_getIndexOfItemWithKey",
    value: function _getIndexOfItemWithKey(keyFn, list, itemKey) {
      for (var i = 0, len = list.length; i < len; i++) {
        if (keyFn(list[i]) === itemKey) {
          return i;
        }
      }

      throw new Error('Failed to find drag index');
    }
  }, {
    key: "_getKeyFn",
    value: function _getKeyFn(itemKey) {
      return typeof itemKey === 'function' ? itemKey : function (x) {
        return x[itemKey];
      };
    }
  }]);
  return DraggableList;
}(React.Component);

exports["default"] = DraggableList;
(0, _defineProperty2["default"])(DraggableList, "propTypes", {
  itemKey: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,
  template: PropTypes.func,
  list: PropTypes.array.isRequired,
  onMoveEnd: PropTypes.func,
  container: PropTypes.func,
  springConfig: PropTypes.object,
  constrainDrag: PropTypes.bool,
  padding: PropTypes.number,
  unsetZIndex: PropTypes.bool,
  autoScrollMaxSpeed: PropTypes.number.isRequired,
  autoScrollRegionSize: PropTypes.number.isRequired,
  commonProps: PropTypes.object
});
(0, _defineProperty2["default"])(DraggableList, "defaultProps", {
  springConfig: {
    stiffness: 300,
    damping: 50
  },
  padding: 10,
  unsetZIndex: false,
  constrainDrag: false,
  autoScrollMaxSpeed: 15,
  autoScrollRegionSize: 30
});
module.exports = exports.default;
module.exports.default = exports.default;
//# sourceMappingURL=index.js.map